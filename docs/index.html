<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dokumentation Qualitätsprojekt</title>
    <link rel="stylesheet" href="assets/styles.css" />
  </head>
  <body>
    <header>
      <h1>Dokumentation Qualitätsprojekt</h1>
      <p>
        Zusammenführung aller Kapitel als zusammenhängendes Dokument mit 
        DIN&nbsp;A4-Seitenlayout für die Veröffentlichung über GitHub Pages.
      </p>
    </header>
    <main>
      <p id="status" class="loading">Inhalte werden geladen …</p>
      <div id="document"></div>
    </main>
    <footer>
      Erstellt für die Veröffentlichung auf GitHub Pages · Format optimiert für DIN&nbsp;A4.
    </footer>
    <script>
      const sections = [
        {
          file: "content/01-rahmendaten-und-kontext.md",
          heading: "01 – Rahmendaten und Kontext"
        },
        {
          file: "content/02-ausgangslage-und-motivation.md",
          heading: "02 – Ausgangslage und Motivation"
        },
        {
          file: "content/03-leitfragen-und-projektziele.md",
          heading: "03 – Leitfragen und Projektziele"
        },
        {
          file: "content/04-vorgehensweise-und-arbeitspakete.md",
          heading: "04 – Vorgehensweise und Arbeitspakete"
        },
        {
          file: "content/05-ergebnisse-je-leitfrage.md",
          heading: "05 – Ergebnisse je Leitfrage"
        },
        {
          file: "content/06-zeitplan-und-meilensteine.md",
          heading: "06 – Zeitplan und Meilensteine"
        },
        {
          file: "content/07-wirkung-und-nachhaltigkeit.md",
          heading: "07 – Wirkung und Nachhaltigkeit"
        },
        {
          file: "content/08-naechste-schritte.md",
          heading: "08 – Nächste Schritte"
        },
        {
          file: "content/09-zusammenfassung.md",
          heading: "09 – Zusammenfassung"
        }
      ];

      const statusNode = document.getElementById("status");
      const docNode = document.getElementById("document");

      const PAGE_HEIGHT_MM = 297;
      const rootStyles = getComputedStyle(document.documentElement);
      const pagePaddingValue = parseFloat(
        rootStyles.getPropertyValue("--page-padding-mm")?.trim() ?? "20"
      );
      const PAGE_PADDING_MM = Number.isFinite(pagePaddingValue)
        ? pagePaddingValue
        : 20;

      function getPxPerMillimeter() {
        const probe = document.createElement("div");
        probe.style.position = "absolute";
        probe.style.width = "1mm";
        probe.style.height = "1mm";
        probe.style.visibility = "hidden";
        document.body.appendChild(probe);
        const { height } = probe.getBoundingClientRect();
        document.body.removeChild(probe);
        return height;
      }

      const pxPerMm = getPxPerMillimeter();
      const maxContentHeightPx =
        (PAGE_HEIGHT_MM - PAGE_PADDING_MM * 2) * pxPerMm;

      function sanitizeFootnoteId(id) {
        return id.replace(/[^A-Za-z0-9_-]/g, "-");
      }

      function extractFootnotes(markdown) {
        const lines = markdown.split(/\r?\n/);
        const definitions = new Map();
        const bodyLines = [];

        for (let index = 0; index < lines.length; index += 1) {
          const line = lines[index];
          const match = line.match(/^\[\^([^\]]+)\]:\s*(.*)$/);

          if (!match) {
            bodyLines.push(line);
            continue;
          }

          const identifier = sanitizeFootnoteId(match[1].trim());
          let definitionText = match[2]?.trim() ?? "";

          const continuation = [];
          let lookahead = index + 1;
          while (lookahead < lines.length) {
            const nextLine = lines[lookahead];
            if (/^( {2,}|\t)/.test(nextLine)) {
              continuation.push(nextLine.trim());
              lookahead += 1;
              continue;
            }

            if (nextLine.trim() === "") {
              continuation.push("");
              lookahead += 1;
              continue;
            }

            break;
          }

          if (continuation.length > 0) {
            const merged = [definitionText, ...continuation]
              .filter((segment) => segment !== undefined)
              .join("\n")
              .trim();
            definitionText = merged;
          }

          if (definitionText) {
            definitions.set(identifier, definitionText);
          }

          index = lookahead - 1;
        }

        return {
          markdown: bodyLines.join("\n"),
          definitions
        };
      }

      function applyFootnotes(container, { definitions, markedLib }) {
        if (!definitions || definitions.size === 0) {
          return;
        }

        const orderMap = new Map();
        const orderList = [];
        const referenceCounts = new Map();
        const backrefs = new Map();

        function processTextNode(node) {
          const text = node.textContent ?? "";
          const footnotePattern = /\[\^([^\]\s]+)\]/g;
          let match;
          let lastIndex = 0;
          let hasFootnote = false;
          const fragment = document.createDocumentFragment();

          while ((match = footnotePattern.exec(text)) !== null) {
            hasFootnote = true;
            const prefix = text.slice(lastIndex, match.index);
            if (prefix) {
              fragment.appendChild(document.createTextNode(prefix));
            }

            lastIndex = match.index + match[0].length;
            const rawId = match[1];
            const normalizedId = sanitizeFootnoteId(rawId);

            if (!definitions.has(normalizedId)) {
              fragment.appendChild(document.createTextNode(match[0]));
              continue;
            }

            if (!orderMap.has(normalizedId)) {
              orderMap.set(normalizedId, orderMap.size + 1);
              orderList.push(normalizedId);
            }

            const referenceIndex = orderMap.get(normalizedId);
            const refCount = (referenceCounts.get(normalizedId) ?? 0) + 1;
            referenceCounts.set(normalizedId, refCount);

            const anchorId = `fnref-${normalizedId}-${refCount}`;
            if (!backrefs.has(normalizedId)) {
              backrefs.set(normalizedId, []);
            }
            backrefs.get(normalizedId).push(anchorId);

            const sup = document.createElement("sup");
            sup.className = "footnote-ref";

            const anchor = document.createElement("a");
            anchor.href = `#fn-${normalizedId}`;
            anchor.id = anchorId;
            anchor.textContent = String(referenceIndex);

            sup.appendChild(anchor);
            fragment.appendChild(sup);
          }

          if (!hasFootnote) {
            return;
          }

          const suffix = text.slice(lastIndex);
          if (suffix) {
            fragment.appendChild(document.createTextNode(suffix));
          }

          node.parentNode?.replaceChild(fragment, node);
        }

        const walker = document.createTreeWalker(
          container,
          NodeFilter.SHOW_TEXT,
          null
        );

        const textNodes = [];
        let currentNode;
        while ((currentNode = walker.nextNode())) {
          textNodes.push(currentNode);
        }

        textNodes.forEach(processTextNode);

        if (orderList.length === 0) {
          return;
        }

        const footnoteSection = document.createElement("section");
        footnoteSection.className = "footnotes";

        const separator = document.createElement("hr");
        separator.className = "footnotes-separator";
        footnoteSection.appendChild(separator);

        const list = document.createElement("ol");
        list.className = "footnotes-list";
        footnoteSection.appendChild(list);

        for (const identifier of orderList) {
          const definition = definitions.get(identifier);
          if (!definition) {
            continue;
          }

          const item = document.createElement("li");
          item.id = `fn-${identifier}`;
          item.className = "footnote-item";

          const definitionContainer = document.createElement("div");
          definitionContainer.innerHTML = markedLib.parseInline(definition);

          if (definitionContainer.childNodes.length === 0) {
            definitionContainer.textContent = definition;
          }

          while (definitionContainer.firstChild) {
            item.appendChild(definitionContainer.firstChild);
          }

          const refAnchors = backrefs.get(identifier) ?? [];
          if (refAnchors.length > 0) {
            const backrefContainer = document.createElement("span");
            backrefContainer.className = "footnote-backrefs";

            refAnchors.forEach((anchorId, index) => {
              if (index > 0) {
                backrefContainer.appendChild(document.createTextNode(" "));
              }

              const backrefLink = document.createElement("a");
              backrefLink.className = "footnote-backref";
              backrefLink.href = `#${anchorId}`;
              backrefLink.setAttribute("aria-label", "Zurück zum Text");
              backrefLink.textContent = `↩︎${refAnchors.length > 1 ? index + 1 : ""}`;
              backrefContainer.appendChild(backrefLink);
            });

            if (item.childNodes.length > 0) {
              item.appendChild(document.createTextNode(" "));
            }

            item.appendChild(backrefContainer);
          }

          list.appendChild(item);
        }

        container.appendChild(footnoteSection);
      }

      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = src;
          script.defer = true;
          script.onload = () => resolve();
          script.onerror = () =>
            reject(new Error(`Konnte ${src} nicht laden.`));
          document.head.appendChild(script);
        });
      }

      async function ensureMarked() {
        if (window.marked) {
          return window.marked;
        }

        const sources = [
          "assets/marked.min.js",
          "https://cdn.jsdelivr.net/npm/marked@12/lib/marked.min.js"
        ];

        let lastError;
        for (const source of sources) {
          try {
            await loadScript(source);
            if (window.marked) {
              return window.marked;
            }
          } catch (error) {
            lastError = error;
          }
        }

        throw lastError ?? new Error("Konvertierungsbibliothek konnte nicht geladen werden.");
      }

      function createPage(title, continuationIndex = 0) {
        const page = document.createElement("section");
        page.className = "page";

        const heading = document.createElement("h1");
        if (continuationIndex === 0) {
          heading.textContent = title;
        } else if (continuationIndex === 1) {
          heading.textContent = `${title} – Fortsetzung`;
        } else {
          heading.textContent = `${title} – Fortsetzung ${continuationIndex}`;
        }
        page.appendChild(heading);

        const content = document.createElement("div");
        content.className = "page-content";
        page.appendChild(content);

        docNode.appendChild(page);

        return { page, content };
      }

      function appendNodeWithPagination({
        nodes,
        title
      }) {
        if (nodes.length === 0) {
          return;
        }

        let continuationIndex = 0;
        let { content, page } = createPage(title, continuationIndex);

        const workQueue = nodes.filter(
          (node) => !(node.nodeType === Node.TEXT_NODE && node.textContent?.trim() === "")
        );

        for (const node of workQueue) {
          content.appendChild(node);
          const contentHeight = content.getBoundingClientRect().height;

          if (contentHeight <= maxContentHeightPx + 0.5) {
            continue;
          }

          content.removeChild(node);

          const hasContent = content.childNodes.length > 0;
          if (!hasContent) {
            // The node itself is higher than the available space – keep it on this page.
            content.appendChild(node);
            page.classList.add("page--overflow");
            continue;
          }

          continuationIndex += 1;
          ({ content, page } = createPage(title, continuationIndex));
          content.appendChild(node);
        }

        if (content.childNodes.length === 0) {
          docNode.removeChild(page);
        }
      }

      async function renderDocument() {
        try {
          const markedLib = await ensureMarked();

          markedLib.setOptions({
            gfm: true,
            breaks: false,
            mangle: false,
            headerIds: true
          });

          docNode.innerHTML = "";

          for (const section of sections) {
            const response = await fetch(section.file);
            if (!response.ok) {
              throw new Error(`Konnte ${section.file} nicht laden (${response.status})`);
            }

            const markdown = await response.text();
            const { markdown: bodyMarkdown, definitions } =
              extractFootnotes(markdown);
            const html = markedLib.parse(bodyMarkdown);
            const container = document.createElement("div");
            container.innerHTML = html;
            applyFootnotes(container, { definitions, markedLib });
            appendNodeWithPagination({
              nodes: Array.from(container.childNodes),
              title: section.heading
            });
          }

          statusNode?.remove();
        } catch (error) {
          console.error(error);
          if (statusNode) {
            statusNode.textContent =
              error?.message === "Konvertierungsbibliothek konnte nicht geladen werden."
                ? error.message
                : "Fehler beim Laden der Inhalte. Bitte versuchen Sie es erneut.";
            statusNode.className = "error";
          }
        }
      }

      renderDocument();
    </script>
  </body>
</html>
